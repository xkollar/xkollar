<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>xkollar - Fine-grained IO with mtl Simplified</title>
<link rel="feed" type="application/atom+xml" href="../atom.xml" title="Atom Feed">
<link rel="shortcut icon" type="image/x-icon" href="../images/favicon.ico" sizes="16x16 32x32 48x48 64x64 128x128 256x256">
<link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body><div class="wrapper"><header><span id="not-title">xkollar</span><nav><ul><li><a href="../">Main</a></li><span class="space"> </span><li><a href="../archive.html">Archive</a> <ul class="tags"><li><a href="../tags/Fun.html">Fun</a></li><span class="space"> </span><li><a href="../tags/Haskell.html">Haskell</a></li><span class="space"> </span><li><a href="../tags/Music.html">Music</a></li><span class="space"> </span><li><a href="../tags/">...</a></li></ul></li></ul></nav></header><div class="main"><h1>Fine-grained IO with mtl Simplified</h1><div class="info">Posted on 2018-03-02 by xkollar  <span class="tags">in <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/mtl.html">mtl</a></span>.</div><p>In <a href="2018-01-25-fine-grained-io-with-mtl.html">previous article</a> I have provided example of how to do selectively add “impure” actions into mtl monadic stack without full power of <code>MonadIO</code>. This what I have done though was to define separate newtype wrappers, which is useful if you want to have more cotrol and flexibility over possible interpreters. Most of the time however, you just want to have simpler code. If that is what you are aiming for, you can have just one wrapper newtype and provide all instances for this particular wrapper.</p>
<p>Diff.</p>
<div class="sourceCode"><pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -27,18 +27,12 @@ class WriteFile m where</span>
     writeFile :: FilePath -&gt; String -&gt; m ()
 
 -- NEWTYPES -------------------------------------
<span class="st">-newtype ReadFileT m a = ReadFile { runReadFile :: m a }</span>
<span class="st">-  deriving (Functor, Applicative, Monad, MonadIO)</span>
<span class="st">-</span>
<span class="st">-newtype WriteFileT m a = WriteFile { runWriteFile :: m a }</span>
<span class="va">+newtype SimpleIORunnerT m a = SimpleIORunner { runSimpleRunner :: m a }</span>
   deriving (Functor, Applicative, Monad, MonadIO)
 
 -- INSTANCES ------------------------------------
<span class="st">-instance MonadTrans ReadFileT where</span>
<span class="st">-    lift = ReadFile</span>
<span class="st">-</span>
<span class="st">-instance MonadTrans WriteFileT where</span>
<span class="st">-    lift = WriteFile</span>
<span class="va">+instance MonadTrans SimpleIORunnerT where</span>
<span class="va">+    lift = SimpleIORunner</span>
 
 instance {-# OVERLAPPABLE #-} (Monad m, MonadTrans t, ReadFile m) =&gt; ReadFile (t m) where
     readFile = lift . readFile
<span class="dt">@@ -46,10 +40,10 @@ instance {-# OVERLAPPABLE #-} (Monad m, MonadTrans t, ReadFile m) =&gt; ReadFile (t</span>
 instance {-# OVERLAPPABLE #-} (Monad m, MonadTrans t, WriteFile m) =&gt; WriteFile (t m) where
     writeFile fp = lift . writeFile fp
 
<span class="st">-instance {-# OVERLAPS #-} MonadIO m =&gt; ReadFile (ReadFileT m) where</span>
<span class="va">+instance {-# OVERLAPS #-} MonadIO m =&gt; ReadFile (SimpleIORunnerT m) where</span>
     readFile = liftIO . IO.readFile
 
<span class="st">-instance {-# OVERLAPS #-} MonadIO m =&gt; WriteFile (WriteFileT m) where</span>
<span class="va">+instance {-# OVERLAPS #-} MonadIO m =&gt; WriteFile (SimpleIORunnerT m) where</span>
     writeFile fp = liftIO . IO.writeFile fp
 
 -- EXAMPLE --------------------------------------
<span class="dt">@@ -68,7 +62,7 @@ combinedAction :: (MonadReader What m, ReadFile m, WriteFile m) =&gt; m ()</span>
 combinedAction = readAction &gt;&gt;= writeAction
 
 example1 :: IO ()
<span class="st">-example1 = runWriteFile . runReadFile $ runReaderT combinedAction conf</span>
<span class="va">+example1 = runSimpleRunner $ runReaderT combinedAction conf</span>
   where
     conf = What &quot;/etc/resolv.conf&quot; &quot;/dev/stdout&quot;</code></pre></div>
<p>Full code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (<span class="dt">Applicative</span>, pure, (&lt;*&gt;))
<span class="kw">import </span><span class="dt">Control.Monad</span> (<span class="dt">Monad</span>, (&gt;&gt;=))
<span class="kw">import </span><span class="dt">Data.Function</span> (($), (.), flip, const)
<span class="kw">import </span><span class="dt">Data.Functor</span> (<span class="dt">Functor</span>, fmap)
<span class="kw">import </span><span class="dt">Data.String</span> (<span class="dt">String</span>)
<span class="kw">import </span><span class="dt">System.IO</span> (<span class="dt">FilePath</span>, <span class="dt">IO</span>)
<span class="kw">import qualified</span> <span class="dt">System.IO</span> <span class="kw">as</span> <span class="dt">IO</span> (readFile, writeFile)

<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span> (<span class="dt">MonadIO</span>, liftIO)
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> (<span class="dt">MonadReader</span>, asks, runReaderT)
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span> (<span class="dt">MonadTrans</span>, lift)


<span class="co">-- CLASSES --------------------------------------</span>
<span class="kw">class</span> <span class="dt">ReadFile</span> m <span class="kw">where</span>
<span class="ot">    readFile ::</span> FilePath <span class="ot">-&gt;</span> m <span class="dt">String</span>

<span class="kw">class</span> <span class="dt">WriteFile</span> m <span class="kw">where</span>
<span class="ot">    writeFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()

<span class="co">-- STACK ----------------------------------------</span>
<span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">ReadFile</span> m) <span class="ot">=&gt;</span> <span class="dt">ReadFile</span> (t m) <span class="kw">where</span>
    readFile <span class="fu">=</span> lift <span class="fu">.</span> readFile

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t, <span class="dt">WriteFile</span> m) <span class="ot">=&gt;</span> <span class="dt">WriteFile</span> (t m) <span class="kw">where</span>
    writeFile fp <span class="fu">=</span> lift <span class="fu">.</span> writeFile fp

<span class="co">-- NEWTYPES and basic INSTANCES -----------------</span>
<span class="kw">newtype</span> <span class="dt">SimpleIORunnerT</span> m a <span class="fu">=</span> <span class="dt">SimpleIORunner</span> {<span class="ot"> runSimpleRunner ::</span> m a }
  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadIO</span>)

<span class="kw">instance</span> <span class="dt">MonadTrans</span> <span class="dt">SimpleIORunnerT</span> <span class="kw">where</span>
    lift <span class="fu">=</span> <span class="dt">SimpleIORunner</span>

<span class="co">-- IMPLEMENTATIONS ------------------------------</span>
<span class="kw">instance</span> <span class="ot">{-# OVERLAPS #-}</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">ReadFile</span> (<span class="dt">SimpleIORunnerT</span> m) <span class="kw">where</span>
    readFile <span class="fu">=</span> liftIO <span class="fu">.</span> <span class="dt">IO</span><span class="fu">.</span>readFile

<span class="kw">instance</span> <span class="ot">{-# OVERLAPS #-}</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">WriteFile</span> (<span class="dt">SimpleIORunnerT</span> m) <span class="kw">where</span>
    writeFile fp <span class="fu">=</span> liftIO <span class="fu">.</span> <span class="dt">IO</span><span class="fu">.</span>writeFile fp

<span class="co">-- EXAMPLE --------------------------------------</span>
<span class="kw">data</span> <span class="dt">What</span> <span class="fu">=</span> <span class="dt">What</span>
    {<span class="ot"> from ::</span> FilePath
    ,<span class="ot"> to ::</span> FilePath
    }

<span class="ot">readAction ::</span> (<span class="dt">MonadReader</span> <span class="dt">What</span> m, <span class="dt">ReadFile</span> m) <span class="ot">=&gt;</span> m <span class="dt">String</span>
readAction <span class="fu">=</span> asks from <span class="fu">&gt;&gt;=</span> readFile

<span class="ot">writeAction ::</span> (<span class="dt">MonadReader</span> <span class="dt">What</span> m, <span class="dt">WriteFile</span> m) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()
writeAction c <span class="fu">=</span> asks to <span class="fu">&gt;&gt;=</span> flip writeFile c

<span class="ot">combinedAction ::</span> (<span class="dt">MonadReader</span> <span class="dt">What</span> m, <span class="dt">ReadFile</span> m, <span class="dt">WriteFile</span> m) <span class="ot">=&gt;</span> m ()
combinedAction <span class="fu">=</span> readAction <span class="fu">&gt;&gt;=</span> writeAction

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runSimpleRunner <span class="fu">$</span> runReaderT combinedAction conf
  <span class="kw">where</span>
    conf <span class="fu">=</span> <span class="dt">What</span> <span class="st">&quot;/etc/resolv.conf&quot;</span> <span class="st">&quot;/dev/stdout&quot;</span></code></pre></div>
</div><footer><p>Find me on <a href="https://github.com/xkollar/">GitHub</a>. Fancy an <a href="../atom.xml">Atom feed</a>?</p><p>H4sIAIisZlgAA3PLzy9JLdLT0wMAzFDh2gkAAAA=</p><p>Version 1, powered by <a href="https://jaspervdj.be/hakyll">Hakyll</a>.</p></footer></div></body>
</html>
